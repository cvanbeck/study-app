<script>
    // Process AI content, separating <think> tags from visible content
    function processAIContent(content) {
        const thoughtMatches = content.match(/<think>[\s\S]*?<\/think>/g) || [];
        const thoughts = thoughtMatches.map(match => match.replace(/<\/?think>/g, "").trim()).join("\n");
        const visibleContent = content.replace(/<think>[\s\S]*?<\/think>/g, "").trim();

        let question = '';
        let answer = '';

        try {
            const start = visibleContent.indexOf('[');
            const end = visibleContent.lastIndexOf(']');
            if (start !== -1 && end !== -1) {
                const jsonString = visibleContent.substring(start, end + 1);
                const parsed = JSON.parse(jsonString);

                if (Array.isArray(parsed) && parsed.length > 0) {
                    const first = parsed[0];
                    const keys = Object.keys(first).reduce((acc, key) => {
                        acc[key.toLowerCase()] = first[key];
                        return acc;
                    }, {});

                    question = keys["question"]?.toString().trim() || '';
                    answer = keys["answer"]?.toString().trim() || '';
                }
            }
        }catch (e){
            console.warn("Failed to parse JSON from AI:", e);
        }
        return{
            thoughts,
            visible: question ? `${question}\n\nYourName: YourAnswer` : visibleContent,
            question,
            answer
        };
    }


    // Render the full AI response into the container
    function renderFullResponse(fullRawContent, container, isFinal = false) {
        const $container = $(container);
        if ($container.length ===0) {
            console.error('Container not found for AI response.');
            return;
        }
        const processedContent = processAIContent(fullRawContent);
        $container.empty();
        // Retrieve the current default from settings.
        const thoughtsDefault = $('input[name="thoughtsDefault"]:checked').val();
        if (typeof window.persistedThoughtsState === 'undefined') {
            window.persistedThoughtsState = (thoughtsDefault === 'open');
        }
        container.innerHTML = '';

        // Process <think> content (hidden internal logic)
        if (processedContent.thoughts.trim()) {
            const detailsElement = document.createElement('details');
            detailsElement.className = 'ai-think';
            if (window.persistedThoughtsState) {
                detailsElement.setAttribute('open', '');
            }
            const summaryElement = document.createElement('summary');
            summaryElement.textContent = isFinal ? 'Thoughts' : 'Thinking...';
            detailsElement.appendChild(summaryElement);

            const innerDiv = document.createElement('div');
            innerDiv.className = 'markdown-content';
            innerDiv.innerHTML = processMathContent(processedContent.thoughts);
            detailsElement.appendChild(innerDiv);
            container.append(detailsElement);

            detailsElement.addEventListener('toggle', function () {
                window.persistedThoughtsState = detailsElement.open;
            });
        }

        // Process visible content
        if (processedContent.visible) {
            const visibleContentDiv = document.createElement('div');
            visibleContentDiv.className = 'markdown-content';
            visibleContentDiv.innerHTML = processMathContent(processedContent.visible);
            container.appendChild(visibleContentDiv);
        }

        // Trigger MathJax rendering
        if (typeof MathJax !== 'undefined') {
            MathJax.typesetPromise([container]).catch(function (err) {
                console.error('MathJax typeset failed: ', err);
            });
        }
    }

    // Escape HTML entities to prevent script injection
    function escapeHTML(str) {
        return str.replace(/[&<>"']/g, function (match) {
            const escapeMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            };
            return escapeMap[match];
        });
    }
</script>
