<script>
    // Process AI content, separating <think> tags from visible content
    function processAIContent(content) {
        const visibleContent = content.replace(/<think>[\s\S]*?<\/think>/g, "").trim();
        const thoughtMatches = content.match(/<think>[\s\S]*?<\/think>/g) || [];
        const thoughts = thoughtMatches.map(match => match.replace(/<\/?think>/g, "").trim()).join("\n");

        let question = '';
        let answer = '';

        try {
            const start = visibleContent.indexOf('{');
            const end = visibleContent.lastIndexOf('}');
            if (start !== -1 && end !== -1) {
                const jsonString = visibleContent.substring(start, end + 1);
                const parsed = JSON.parse(jsonString);

                if (Array.isArray(parsed)) {
                    if (parsed.length >= 2) {
                        question = parsed[0]?.toString().trim() || '';
                        answer = parsed[1]?.toString().trim() || '';
                    }
                }else if(
                    typeof parsed === 'object' &&
                    parsed !== null &&
                    'question' in parsed &&
                    'answer' in parsed
                ){
                    question = parsed.question?.toString().trim() || '';
                    answer = parsed.answer?.toString().trim() || '';
                }
            }
        }catch (e){
            console.warn("Failed to parse JSON from AI:", e);
        }
        return{
            thoughts,
            visible: question || visibleContent,
            question,
            answer
        };
    }


    // Render the full AI response into the container
    function renderFullResponse(fullRawContent, container, isFinal = false) {
        const $container = $(container);
        if ($container.length ===0) {
            console.error('Container not found for AI response.');
            return;
        }
        const processedContent = processAIContent(fullRawContent);
        $container.empty();
        // Retrieve the current default from settings.
        const thoughtsDefault = $('input[name="thoughtsDefault"]:checked').val();
        if (typeof window.persistedThoughtsState === 'undefined') {
            window.persistedThoughtsState = (thoughtsDefault === 'open');
        }
        container.innerHTML = '';

        // Process <think> content (hidden internal logic)
        if (processedContent.thoughts.trim()) {
            const detailsElement = document.createElement('details');
            detailsElement.className = 'ai-think';
            if (window.persistedThoughtsState) {
                detailsElement.setAttribute('open', '');
            }
            const summaryElement = document.createElement('summary');
            summaryElement.textContent = isFinal ? 'Thoughts' : 'Thinking...';
            detailsElement.appendChild(summaryElement);

            const innerDiv = document.createElement('div');
            innerDiv.className = 'markdown-content';
            innerDiv.innerHTML = processMathContent(processedContent.thoughts);
            detailsElement.appendChild(innerDiv);
            container.append(detailsElement);

            detailsElement.addEventListener('toggle', function () {
                window.persistedThoughtsState = detailsElement.open;
            });
        }

        // Process visible content
        if (processedContent.visible) {
            const visibleContentDiv = document.createElement('div');
            visibleContentDiv.className = 'markdown-content';
            let htmlWithLineBreaks = processedContent.visible.replace(/\n/g, '<br>');
            visibleContentDiv.innerHTML = processMathContent(htmlWithLineBreaks);
            container.appendChild(visibleContentDiv);
        }

        // Trigger MathJax rendering
        if (typeof MathJax !== 'undefined') {
            MathJax.typesetPromise([container]).catch(function (err) {
                console.error('MathJax typeset failed: ', err);
            });
        }
    }

    // Escape HTML entities to prevent script injection
    function escapeHTML(str) {
        return str.replace(/[&<>"']/g, function (match) {
            const escapeMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            };
            return escapeMap[match];
        });
    }
</script>
